<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>risk-checker | night (WIP)</title>
  <style>
    /* -------------------------------------------------
       Theme system (auto / light / dark)
       - Fix: button text disappearing in dark mode
       - Keep UI readable on both PC and mobile
    ------------------------------------------------- */

    :root {
      --bg: #fafafa;
      --fg: #111;
      --muted: #666;

      --box-bg: #fff;
      --border: #e5e5e5;
      --card-border: #ddd;

      --note-bg: #f7f7f7;
      --note-border: #e5e5e5;

      --btn-bg: #fff;
      --btn-fg: #111;
      --btn-border: #ccc;
      --btn-bg-hover: #f0f0f0;

      --result-call-bg: #fdeaea;
      --result-call-border: #e0a1a1;
      --result-observe-bg: #eaf2ff;
      --result-observe-border: #a9c3f0;
      --result-sleep-bg: #eef7ef;
      --result-sleep-border: #a9d4ad;
    }

    html[data-theme="light"] { color-scheme: light; }
    html[data-theme="dark"]  { color-scheme: dark; }

    /* Auto follows OS preference */
    html[data-theme="auto"] { color-scheme: light dark; }

    html[data-theme="dark"] {
      --bg: #0b0c10;
      --fg: #f3f4f6;
      --muted: #a9adb7;

      --box-bg: #0f1117;
      --border: #2a2f3a;
      --card-border: #2a2f3a;

      --note-bg: #121624;
      --note-border: #2a2f3a;

      --btn-bg: #151a24;
      --btn-fg: #f3f4f6;
      --btn-border: #2a2f3a;
      --btn-bg-hover: #1a2030;

      --result-call-bg: #2a1212;
      --result-call-border: #7a2c2c;
      --result-observe-bg: #0f1a2f;
      --result-observe-border: #2b4a86;
      --result-sleep-bg: #0f2413;
      --result-sleep-border: #2f6a3a;
    }

    @media (prefers-color-scheme: dark) {
      html[data-theme="auto"] {
        --bg: #0b0c10;
        --fg: #f3f4f6;
        --muted: #a9adb7;

        --box-bg: #0f1117;
        --border: #2a2f3a;
        --card-border: #2a2f3a;

        --note-bg: #121624;
        --note-border: #2a2f3a;

        --btn-bg: #151a24;
        --btn-fg: #f3f4f6;
        --btn-border: #2a2f3a;
        --btn-bg-hover: #1a2030;

        --result-call-bg: #2a1212;
        --result-call-border: #7a2c2c;
        --result-observe-bg: #0f1a2f;
        --result-observe-border: #2b4a86;
        --result-sleep-bg: #0f2413;
        --result-sleep-border: #2f6a3a;
      }
    }

    @media (max-width: 600px){
      #theme-toggle { display:none; }
    }

    body {
      font-family: system-ui, -apple-system, "Hiragino Sans", "Noto Sans JP", sans-serif;
      margin: 24px;
      line-height: 1.6;
      background: var(--bg);
      color: var(--fg);
    }

    .box {
      max-width: 860px;
      background: var(--box-bg);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    h1 { margin: 0 0 8px; font-size: 22px; }

    .note {
      background: var(--note-bg);
      border: 1px solid var(--note-border);
      padding: 12px 14px;
      border-radius: 10px;
      margin: 12px 0;
    }

    .row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; align-items:center; }

    button {
      padding: 12px 16px;
      border-radius: 10px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-fg);
      cursor: pointer;
      font-weight: 700;
      font-size: 15px;
      line-height: 1.2;
    }

    button:hover { background: var(--btn-bg-hover); }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    button:disabled:hover { background: var(--btn-bg); }

    /* Start screen: make the primary action unmistakable */
    button.big {
      font-size: 18px;
      padding: 14px 18px;
      border-radius: 12px;
      letter-spacing: 0.3px;
    }

    @media (max-width: 600px){
      button.big { width: 100%; }
    }

    .ans-row { gap: 12px; }

    /* Answer buttons (Yes/No/不明) */
    button.ansbtn {
      min-width: 92px;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 16px;
    }

    /* Selected state (so users can SEE their tap worked) */
    button.ansbtn.active {
      background: var(--btn-bg-hover);
      border-color: var(--btn-border);
      box-shadow: 0 0 0 3px rgba(100, 116, 139, 0.35); /* neutral ring */
    }

    button.danger.active {
      box-shadow: 0 0 0 3px rgba(224, 161, 161, 0.35);
      border-color: var(--result-call-border);
    }

    button.primary.active {
      box-shadow: 0 0 0 3px rgba(169, 195, 240, 0.35);
      border-color: var(--result-observe-border);
    }

    @media (max-width: 600px){
      button.ansbtn { flex: 1; min-width: 0; }
      .ans-row { flex-wrap: nowrap; }
    }

    /* Make the state/action at the top feel primary */
    .state-banner {
      font-size: 16px;
      font-weight: 800;
      border-radius: 12px;
      padding: 14px;
    }

    details.guide {
      margin-top: 10px;
    }

    details.guide > summary {
      cursor: pointer;
      user-select: none;
      font-weight: 700;
    }

    details.guide > summary::-webkit-details-marker {
      display: none;
    }

    details.guide > summary::before {
      content: "▶ ";
      color: var(--muted);
    }

    details.guide[open] > summary::before {
      content: "▼ ";
    }

    button.primary { border-color: var(--btn-border); }
    button.danger { border-color: var(--result-call-border); }

    .card {
      border: 1px solid var(--card-border);
      border-radius: 10px;
      padding: 14px;
      margin: 12px 0;
      background: var(--box-bg);
    }

    .q-title { font-weight: 700; margin: 0 0 6px; }
    .muted { color: var(--muted); font-size: 13px; }

    .pill {
      display:inline-block;
      padding: 2px 10px;
      border:1px solid var(--btn-border);
      border-radius:999px;
      font-size: 12px;
      margin-left: 6px;
      color: var(--muted);
    }

    .result {
      padding: 14px;
      border-radius: 10px;
      border: 1px solid var(--card-border);
      background: var(--box-bg);
      margin-top: 12px;
      white-space: pre-wrap;
    }

    .result.call { background: var(--result-call-bg); border-color: var(--result-call-border); }
    .result.observe { background: var(--result-observe-bg); border-color: var(--result-observe-border); }
    .result.sleep { background: var(--result-sleep-bg); border-color: var(--result-sleep-border); }

    .hr { height:1px; background: var(--border); margin: 14px 0; }
    .small { font-size: 12px; color: var(--muted); }

    a { color: inherit; }
  </style>
</head>

<body>
  <div class="box">
    <h1>night checker (WIP)</h1>
    <div id="theme-toggle" class="row small" style="justify-content:flex-end"></div>

    <div class="note">
      <strong>注意：</strong>
      診断・評価・判断はしません。<br/>
      ここで行うのは <strong>Yes/Noの事実確認</strong> だけです（最終判断は人）。
    </div>

    <div id="view"></div>

    <div class="hr"></div>

    <div class="small">
      ・このページは試作です。<br/>
      ・“OK”“安全”などの断定は出しません。<br/>
      ・必要なら GitHub 上の設計文書に戻る： <a href="https://github.com/risk-checker/risk-checker-core" target="_blank" rel="noreferrer">repo</a>
    </div>
  </div>

  <script>
    /**
     * --------------------------------------------------------------------
     *  State machine (最重要)
     *  - 判断を「人」から外すため、画面遷移を固定する
     * --------------------------------------------------------------------
     */

    const STATE = {
      START: "START",
      Q6: "Q6",
      RESULT_CALL: "RESULT_CALL",
      OBSERVE_30: "OBSERVE_30",
      OBSERVE_60: "OBSERVE_60",
      HANDOFF: "HANDOFF",
      SLEEP_CHECK: "SLEEP_CHECK",
    };

    // 6問（仮文言。あとで確定）
    const Q6 = [
      { id: "q1", text: "反応がない／意識がおかしい（『普段』＝いつものその人の反応がない）" },
      { id: "q2", text: "いつものその人と比べて、息が苦しそう（話が続かない／息継ぎが増えた等）" },
      { id: "q3", text: "出血が止まっていない（清潔なガーゼ/ティッシュで押さえても、1分後にまだ出ている）" },
      { id: "q4", text: "本人が『耐えられない』と訴える強い痛みがある（普段より明らかに強い）" },
      { id: "q5", text: "普段（＝いつものその人は）歩けるのに、今は歩けない" },
      { id: "q6", text: "普段（＝いつものその人は）不要な介助なのに、持ち上げた／抱えた動作があった" },
    ];

    // 睡眠チェック（起こす/起こさないだけ）
    const SLEEP = [
      { id: "s1", text: "呼吸の動きが確認できる（胸・腹部・布団の上下・鼻息など。触れずに確認）" },
      { id: "s2", text: "苦痛の発語（痛い・苦しい・助けて等）が30秒以上連続していない" },
      { id: "s3", text: "顔（鼻・口）が塞がっていない／胸や腹が何かに押しつぶされていない" },
    ];

    const model = {
      state: STATE.START,
      answers: Object.fromEntries(Q6.map(q => [q.id, null])),   // null / true / false
      sleep: Object.fromEntries(SLEEP.map(q => [q.id, null])), // null / true / false
      lastRunAt: null,   // 表示用（直近の6問実施時刻）
      firstRunAt: null,  // 初回6問を実施した時刻（30分/60分の基準）
      recheckRound: 0,   // 0=初回,1=30分後,2=60分後
      nextIfAllNo: STATE.OBSERVE_30, // 次に進む固定フロー（全てNoのとき）
      returnAfterSleep: STATE.Q6,    // 睡眠チェック後に戻す画面（導線固定）
    };

    const $view = () => document.getElementById("view");

    // -------------------------------------------------
    // Theme toggle (PC only): auto / light / dark
    // -------------------------------------------------
    const THEME_KEY = "night-theme"; // auto | light | dark

    function applyTheme(mode){
      document.documentElement.dataset.theme = mode;
      localStorage.setItem(THEME_KEY, mode);
    }

    function renderThemeToggle(){
      const wrap = document.getElementById("theme-toggle");
      if(!wrap) return;

      wrap.innerHTML = "";

      const label = document.createElement("span");
      label.textContent = "表示モード：";
      label.style.marginRight = "6px";
      wrap.appendChild(label);

      const options = [
        { mode: "auto",  text: "自動" },
        { mode: "light", text: "ライト" },
        { mode: "dark",  text: "ダーク" },
      ];

      const saved = localStorage.getItem(THEME_KEY) || "auto";

      options.forEach(({mode, text})=>{
        const b = document.createElement("button");
        b.type = "button";
        b.textContent = text;
        b.setAttribute("aria-label", `表示モード: ${text}`);
        if (mode === saved) b.classList.add("active");
        b.onclick = ()=>{
          applyTheme(mode);
          renderThemeToggle();
        };
        wrap.appendChild(b);
      });
    }

    function initTheme(){
      const saved = localStorage.getItem(THEME_KEY) || "auto";
      document.documentElement.dataset.theme = saved;
    }

    // ================================
    // Facility info (local only)
    // ================================
    const FACILITY_KEY = "night-facility";

    const facility = {
      name: "",
      address: "",
      phone: "",
    };

    function loadFacility() {
      try {
        const raw = localStorage.getItem(FACILITY_KEY);
        if (!raw) return;
        const obj = JSON.parse(raw);
        facility.name = obj.name || "";
        facility.address = obj.address || "";
        facility.phone = obj.phone || "";
      } catch (e) {}
    }

    function saveFacility() {
      localStorage.setItem(FACILITY_KEY, JSON.stringify(facility));
    }

    function clearFacility() {
      localStorage.removeItem(FACILITY_KEY);
      facility.name = "";
      facility.address = "";
      facility.phone = "";
    }

    function facilityValue(v) {
      return v && v.trim() ? v : "＿＿＿＿";
    }

    function nowText() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    function resetAll() {
      for (const k of Object.keys(model.answers)) model.answers[k] = null;
      for (const k of Object.keys(model.sleep)) model.sleep[k] = null;
      model.lastRunAt = null;
      model.firstRunAt = null;
      model.recheckRound = 0;
      model.nextIfAllNo = STATE.OBSERVE_30;
      model.returnAfterSleep = STATE.Q6;
      model.state = STATE.START;
      render();
    }

    function anyYes(obj) {
      return Object.values(obj).some(v => v === true);
    }

    function allYes(obj) {
      return Object.values(obj).every(v => v === true);
    }

    function yesQuestionSummary() {
      const yesIdx = [];
      const yesLines = [];
      Q6.forEach((q, i) => {
        if (model.answers[q.id] === true) {
          const n = i + 1;
          yesIdx.push(`Q${n}`);
          yesLines.push(`Q${n}: ${q.text}`);
        }
      });
      return {
        short: yesIdx.length ? yesIdx.join(", ") : "（なし）",
        lines: yesLines.join("\n"),
      };
    }

    function copyText(text){
      try {
        navigator.clipboard.writeText(text);
      } catch (e) {
        // Fallback: create a temporary textarea
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
      }
    }

    function setState(next) {
      model.state = next;
      render();
    }

    function render() {
      const v = $view();
      v.innerHTML = "";

      if (model.state === STATE.START) {
        v.appendChild(screenStart());
        return;
      }
      if (model.state === STATE.Q6) {
        v.appendChild(screenQ6());
        return;
      }
      if (model.state === STATE.RESULT_CALL) {
        v.appendChild(screenCall());
        return;
      }
      if (model.state === STATE.OBSERVE_30) {
        v.appendChild(screenObserve(30, STATE.OBSERVE_60));
        return;
      }
      if (model.state === STATE.OBSERVE_60) {
        v.appendChild(screenObserve(60, STATE.HANDOFF));
        return;
      }
      if (model.state === STATE.SLEEP_CHECK) {
        v.appendChild(screenSleep());
        return;
      }
      if (model.state === STATE.HANDOFF) {
        v.appendChild(screenHandoff());
        return;
      }
    }

    /**
     * Screens
     */

    function screenStart() {
      const wrap = div("card");

      // 1 screen = 1 action
      wrap.appendChild(h2("起動（迷ったら開始）"));
      wrap.appendChild(div(
        "muted",
        "今やること：6問（Yes/No）を開始する。迷ったら開始してOK。"
      ));

      const r = div("row");
      r.appendChild(btn("▶ 開始（6問）", () => {
        model.lastRunAt = nowText();
        model.firstRunAt = model.lastRunAt; // 初回6問の基準時刻
        model.recheckRound = 0;
        model.nextIfAllNo = STATE.OBSERVE_30;
        setState(STATE.Q6);
      }, "primary big"));
      wrap.appendChild(r);

      // Details are available, but not required to proceed
      const details = document.createElement("details");
      details.className = "guide";

      const summary = document.createElement("summary");
      summary.textContent = "詳細（起動条件 / 外部連絡 / 注意）";
      details.appendChild(summary);

      details.appendChild(div(
        "note",
        "起動条件（迷ったら起動）：\n" +
          "・本人の訴え / 夜勤の違和感 / 転倒・出血など出来事 / 第三者報告\n" +
          "・『普段』が分からない → 不明なら安全側（Yes）\n\n" +
          "外部連絡：\n" +
          "・外部（訪問診療/訪問看護）へ連絡してよい（情報共有）\n" +
          "・ただし、このアプリの表示（救急車/再確認）は上書きしない\n\n" +
          "注意：\n" +
          "・このツールは診断・評価・判断をしない（Yes/Noの事実確認のみ）"
      ));

      wrap.appendChild(details);
      
      // ---- Facility settings (local only) ----
      const f = document.createElement("details");
      f.className = "guide";

      const fs = document.createElement("summary");
      fs.textContent = "施設情報（この端末に保存）";
      f.appendChild(fs);

      f.appendChild(div(
        "note",
        "※ この情報はGitHubには保存されません。\n※ この端末のブラウザだけが覚えます。"
      ));

      f.appendChild(inputText("施設名", facility.name, v => facility.name = v));
      f.appendChild(inputText("住所", facility.address, v => facility.address = v));
      f.appendChild(inputText("電話", facility.phone, v => facility.phone = v));

      const fr = div("row");
      fr.appendChild(btn("保存", () => { saveFacility(); render(); }, "primary"));
      fr.appendChild(btn("消去", () => { clearFacility(); render(); }, "danger"));
      f.appendChild(fr);

      wrap.appendChild(f);

      // Minimal footer note
      wrap.appendChild(div("note", "※ このページは“判断”をしません。Yes/Noの事実確認のみです。"));

      return wrap;
    }

    function screenQ6() {
      const wrap = document.createElement("div");

      // safety: 初回の基準時刻が未設定なら、この時点を初回として固定する
      if (model.recheckRound === 0 && !model.firstRunAt) {
        model.firstRunAt = model.lastRunAt || nowText();
        if (!model.lastRunAt) model.lastRunAt = model.firstRunAt;
      }

      // Header
      const head = div("card");
      head.appendChild(h2(`6問（今この瞬間の事実のみ）${model.recheckRound===0?"（初回）":model.recheckRound===1?"（30分後の再実施）":"（60分後の再実施）"}`));
      head.appendChild(div("muted", `最終実行: ${model.lastRunAt ?? "未実行"}`));
      // Night-shift first: show the next action first, keep rules in details
      const banner = div("result observe state-banner",
        "いまやること：6問に Yes/No を入れる → 『確定する』\n" +
        "（推測・原因・評価はしない。迷ったら不明→安全側）"
      );
      head.appendChild(banner);

      const details = document.createElement("details");
      details.className = "guide";
      const summary = document.createElement("summary");
      summary.textContent = "ルール / 補足";
      details.appendChild(summary);
      details.appendChild(div(
        "note",
        "ルール：1つでもYes→救急車（119） / 全てNo→再確認（30→60）。\n" +
          "※推測・原因・評価は禁止。\n" +
          "※『普段』＝いつものその人（正常/理想ではない）。不明なら安全側（Yes）。"
      ));
      head.appendChild(details);
      wrap.appendChild(head);

      // Recheck pre-check (30/60分後の再実施では、まず睡眠/起床状態を確認する導線を上に出す)
      if (model.recheckRound > 0) {
        const pre = div("card");
        pre.appendChild(h2("再確認の前に：起こして確認できる状態か？"));
        pre.appendChild(div(
          "note",
          "再確認（30/60分後）の前に：起こして6問できる状態か確認。\n" +
          "睡眠か不明なら先に睡眠チェック（救急車判定はしない）。"
        ));
        const rr = div("row");
        rr.appendChild(btn("睡眠か不明 → 睡眠チェックへ", () => {
          model.returnAfterSleep = STATE.Q6;
          setState(STATE.SLEEP_CHECK);
        }, "primary"));
        rr.appendChild(btn("起きている/確認できる → このまま6問を続ける", () => {
          // 何もしない（画面をそのまま）
        }));
        pre.appendChild(rr);
        wrap.appendChild(pre);
      }
      // Questions
      Q6.forEach((q, i) => {
        const card = div("card");
        const title = document.createElement("div");
        title.className = "q-title";
        title.textContent = `Q${i+1}. ${q.text}`;
        card.appendChild(title);

        const r = div("row ans-row");

        const bYes = btn("はい", () => { model.answers[q.id] = true; render(); }, "danger ansbtn");
        const bNo  = btn("いいえ", () => { model.answers[q.id] = false; render(); }, "ansbtn");
        const bNil = btn("未回答", () => { model.answers[q.id] = null; render(); }, "ansbtn");

        // Visual feedback (selected state)
        if (model.answers[q.id] === true) bYes.classList.add("active");
        if (model.answers[q.id] === false) bNo.classList.add("active");
        if (model.answers[q.id] === null) bNil.classList.add("active");

        r.appendChild(bYes);
        r.appendChild(bNo);
        r.appendChild(bNil);

        card.appendChild(r);

        wrap.appendChild(card);
      });

      // Actions
      const foot = div("card");
      foot.appendChild(h2("判定（自動）"));

      const undecided = Object.values(model.answers).some(v => v === null);
      const info = div("muted", undecided
        ? "※ 未回答があります。すべて回答してから確定してください。"
        : "※ すべて回答済みです。"
      );
      foot.appendChild(info);

      const r = div("row");

      const confirmBtn = btn("確定する", () => {
        // Guard: should be unreachable when disabled, but keep safe
        if (Object.values(model.answers).some(v => v === null)) return;
        if (anyYes(model.answers)) {
          setState(STATE.RESULT_CALL);
        } else {
          setState(model.nextIfAllNo);
        }
      }, "primary");

      // A) 未回答は許すが、確定（行動決定）は許さない
      if (undecided) {
        confirmBtn.disabled = true;
        confirmBtn.setAttribute("aria-disabled", "true");
      }

      r.appendChild(confirmBtn);

      r.appendChild(btn("最初からやり直す", () => resetAll()));
      foot.appendChild(r);

      wrap.appendChild(foot);
      return wrap;
    }

    function screenCall() {
      const wrap = document.createElement("div");
      const card = div("card");

      const summary = yesQuestionSummary();

      card.appendChild(h2("表示：救急車（119）"));

      // Primary, big, unmissable state/action
      const primary = div(
        "result call state-banner",
        "✅ 行動：119（救急車）\n" +
          "条件一致：Yesあり（" + summary.short + "）"
      );
      card.appendChild(primary);

      // Show exactly which questions were Yes
      const yesBox = div(
        "note",
        "Yesになった問診（救急隊へ伝える用）：\n" +
          (summary.lines ? summary.lines : "（なし）")
      );
      card.appendChild(yesBox);

      // Minimal script for the call (copyable)
      const callText = [
        "【救急要請（119）】",
        `こちらは ${facilityValue(facility.name)} です。`,
        `住所は ${facilityValue(facility.address)} です。`,
        facilityValue(facility.phone) !== "＿＿＿＿" ? `折り返し電話は ${facilityValue(facility.phone)} です。` : "折り返し電話は（未入力）です。",
        "利用者：＿＿歳、＿＿性。",
        `『6問』で Yes になったのは ${summary.short} です。`,
        "（内容を読み上げます）",
        summary.lines ? summary.lines : "（Yesの詳細はなし）",
        "※原因の推測や評価は言いません。"
      ].join("\n");

      const copyWrap = div("card");
      copyWrap.appendChild(h2("救急隊へ伝える（読み上げ/コピペ用）"));
      copyWrap.appendChild(div("muted", "空欄は口頭で補ってOK。『Yesになった問診』だけ伝える。"));
      copyWrap.appendChild(div("result", callText));

      const cr = div("row");
      cr.appendChild(btn("コピーする", () => copyText(callText), "primary"));
      copyWrap.appendChild(cr);
      card.appendChild(copyWrap);

      // External contact rule (kept short)
      card.appendChild(div(
        "note",
        "外部（訪問診療/訪問看護）は『状態通知』のみ。判定の相談・上書きはしない。\n" +
          "※搬送先は救急隊。"
      ));

      const r = div("row");
      r.appendChild(btn("6問へ戻る（状況変化）", () => setState(STATE.Q6)));
      r.appendChild(btn("最初からやり直す", () => resetAll()));
      card.appendChild(r);

      wrap.appendChild(card);
      return wrap;
    }

    function screenObserve(mins, nextState) {
      const card = div("card");

      // 言葉の置き換え："経過観察" → "様子を見る（再チェック待ち）"
      const stateTitle = `状態：様子を見る（再チェック待ち ${mins}分）`;
      card.appendChild(h2(stateTitle));

      // まず「次に何をするか」を最大優先で表示
      const base = model.firstRunAt ?? "未記録";
      const banner = div(
        "result observe state-banner",
        `次にすること：${mins}分たったら『6問を再チェック』\n` +
          `（基準：初回6問 ${base} からの経過）`
      );
      card.appendChild(banner);

      // ボタンは迷いを増やさない：主ボタン + 補助ボタンの2つ
      const r = div("row");

      // 主：再チェック（6問へ）
      r.appendChild(
        btn(
          "6問を再チェックする",
          () => {
            model.lastRunAt = nowText();
            for (const k of Object.keys(model.answers)) model.answers[k] = null;

            if (mins === 30) {
              model.recheckRound = 1;
              model.nextIfAllNo = STATE.OBSERVE_60;
            } else {
              model.recheckRound = 2;
              model.nextIfAllNo = STATE.HANDOFF;
            }

            setState(STATE.Q6);
          },
          "primary big"
        )
      );

      // 補助：睡眠か不明
      r.appendChild(
        btn(
          "眠っているか不明 → 睡眠チェック",
          () => {
            model.returnAfterSleep = nextState || STATE.Q6;
            setState(STATE.SLEEP_CHECK);
          },
          "primary"
        )
      );

      card.appendChild(r);

      // 補足は折りたたみに退避（読みたくない人の邪魔をしない）
      const details = document.createElement("details");
      details.className = "guide";

      const summary = document.createElement("summary");
      summary.textContent = "補足（定義 / 連絡ルール）";
      details.appendChild(summary);

      details.appendChild(
        div(
          "note",
          "『様子を見る（再チェック待ち）』＝いまは原因探しをせず、時間をおいて同じ6問で事実だけをもう一度確認すること。\n" +
            `・${mins}分は『初回6問を実施した時刻』からの経過。\n` +
            "・タイマーは実装しない（現場の時計でOK）。\n\n" +
            "外部連絡：\n" +
            "・外部（訪問診療/訪問看護）へ連絡してよい（情報共有）。\n" +
            "・ただし、この画面の流れ（再チェック/119）は上書きしない。\n" +
            "・本人が『相談したい』と明確に希望した場合のみ、電話を渡す/事実を伝えるのは可。"
        )
      );

      // 例外操作は折りたたみの中へ
      const more = div("row");
      more.appendChild(
        btn(
          "いま悪化/新規事象（最初から6問）",
          () => {
            model.lastRunAt = nowText();
            for (const k of Object.keys(model.answers)) model.answers[k] = null;
            model.recheckRound = 0;
            model.firstRunAt = model.lastRunAt; // 新規事象なので基準を更新
            model.nextIfAllNo = STATE.OBSERVE_30;
            setState(STATE.Q6);
          },
          "danger"
        )
      );
      more.appendChild(btn("最初からやり直す", () => resetAll()));
      details.appendChild(more);

      card.appendChild(details);

      // ログは最小サイズで下に
      card.appendChild(
        div(
          "small",
          `初回：${model.firstRunAt ?? "未記録"} / 最終：${model.lastRunAt ?? "未実行"}`
        )
      );

      return card;
    }

    function screenSleep() {
      const wrap = document.createElement("div");
      const card = div("card");
      card.appendChild(h2("睡眠チェック（睡眠か不明のときの補助）"));
      card.appendChild(div("note",
        "ここで決めるのは『起こして6問』か『起こさず観察』のみ（救急車判定はしない）。\n" +
        "不明が残るなら『起こして6問』に倒す。"
      ));
      wrap.appendChild(card);

      SLEEP.forEach((q, i) => {
        const c = div("card");
        const title = document.createElement("div");
        title.className = "q-title";
        title.textContent = `S${i+1}. ${q.text}`;
        c.appendChild(title);

        const r = div("row ans-row");

        const bYes = btn("はい", () => { model.sleep[q.id] = true; render(); }, "primary ansbtn");
        const bNo  = btn("いいえ", () => { model.sleep[q.id] = false; render(); }, "danger ansbtn");
        const bUnk = btn("不明", () => { model.sleep[q.id] = null; render(); }, "ansbtn");

        // Visual feedback (selected state)
        if (model.sleep[q.id] === true) bYes.classList.add("active");
        if (model.sleep[q.id] === false) bNo.classList.add("active");
        if (model.sleep[q.id] === null) bUnk.classList.add("active");

        r.appendChild(bYes);
        r.appendChild(bNo);
        r.appendChild(bUnk);

        c.appendChild(r);

        wrap.appendChild(c);
      });

      const decision = div("card");
      decision.appendChild(h2("結果（自動）"));

      const hasNull = Object.values(model.sleep).some(v => v === null);
      if (hasNull) {
        decision.appendChild(div("result sleep",
          "⚠ 未回答/不明があります。\n" +
          "不明が残る場合は『起こして6問へ戻す』に倒してください。"
        ));
      } else if (allYes(model.sleep)) {
        decision.appendChild(div("result sleep",
          "✅ すべて Yes。\n" +
          "行動：起こさない（睡眠継続）。\n" +
          "※ 状況変化があれば最初から6問へ。"
        ));
      } else {
        decision.appendChild(div("result sleep",
          "⚠ 1つ以上 No。\n" +
          "行動：起こして6問へ戻す（意識/呼吸等の事実確認へ）。"
        ));
      }

      const r = div("row");

      const hasNull2 = Object.values(model.sleep).some(v => v === null);
      const allYes2 = !hasNull2 && allYes(model.sleep);

      // ルール：表示（自動）とボタンが矛盾しないようにする
      // - 「すべてYes」＝起こさない（観察継続）を主ボタンにし、「起こして戻す」は出さない
      // - 不明/Noがある＝起こして6問へ戻すを主ボタンにする

      if (allYes2) {
        r.appendChild(btn("起こさない（観察を続ける）", () => {
          // 観察継続：次の段階へ（30→60→日勤）
          setState(model.returnAfterSleep);
        }, "primary"));

        r.appendChild(btn("状況変化があれば：最初から6問へ", () => {
          for (const k of Object.keys(model.answers)) model.answers[k] = null;
          model.lastRunAt = nowText();
          setState(STATE.Q6);
        }));

      } else {
        r.appendChild(btn("起こして6問へ戻す", () => {
          // 睡眠チェックは補助なので、6問側を再起動
          for (const k of Object.keys(model.answers)) model.answers[k] = null;
          model.lastRunAt = nowText();
          setState(STATE.Q6);
        }, "primary"));

        r.appendChild(btn("戻る（前の画面へ）", () => {
          setState(STATE.Q6);
        }));
      }

      r.appendChild(btn("最初からやり直す", () => resetAll()));

      decision.appendChild(r);
      wrap.appendChild(decision);

      return wrap;
    }

    function screenHandoff() {
      const card = div("card");
      card.appendChild(h2("引き継ぎ（夜間の判断をここで止める）"));
      card.appendChild(div("result observe",
        "ここから先（翌日通院、家族調整、服薬/生活対応の主体決定）は日勤帯。\n" +
        "夜勤は『事実』と『実施した対応』だけを残す。"
      ));
      card.appendChild(div("note",
        "残すもの（例）\n" +
        "・起動時刻 / きっかけ（訴え・転倒等）\n" +
        "・6問の回答（Yes/No）\n" +
        "・経過観察の実施（30分/60分）\n" +
        "・睡眠チェックの有無\n" +
        "※ 評価・推測・誰が悪いは禁止"
      ));

      const r = div("row");
      r.appendChild(btn("6問へ戻る（状況変化）", () => {
        model.lastRunAt = nowText();
        for (const k of Object.keys(model.answers)) model.answers[k] = null;
        setState(STATE.Q6);
      }));
      r.appendChild(btn("最初からやり直す", () => resetAll()));
      card.appendChild(r);
      return card;
    }

    /**
     * UI helpers
     */

    function h2(text) {
      const el = document.createElement("div");
      el.className = "q-title";
      el.textContent = text;
      return el;
    }

    function p(text) {
      const el = document.createElement("div");
      el.style.whiteSpace = "pre-wrap";
      el.textContent = text;
      return el;
    }

    function div(className, text) {
      const el = document.createElement("div");
      if (className) el.className = className;
      if (text !== undefined) {
        el.style.whiteSpace = "pre-wrap";
        el.textContent = text;
      }
      return el;
    }

    function btn(label, onClick, extraClass) {
      const b = document.createElement("button");
      b.type = "button"; // prevent any accidental form-submit behavior
      if (extraClass) b.className = String(extraClass);
      b.textContent = label;
      b.onclick = onClick;
      return b;
    }

    function spanPill(value) {
      const s = document.createElement("span");
      s.className = "pill";
      if (value === true) s.textContent = "Yes";
      else if (value === false) s.textContent = "No";
      else s.textContent = "未回答";
      return s;
    }

    // Helper: labeled text input (row layout)
    function inputText(label, value, onChange) {
      const row = div("row");

      const l = document.createElement("div");
      l.className = "muted";
      l.style.minWidth = "80px";
      l.textContent = label;

      const i = document.createElement("input");
      i.type = "text";
      i.value = value || "";
      i.style.flex = "1";
      i.style.padding = "12px";
      i.oninput = () => onChange(i.value);

      row.appendChild(l);
      row.appendChild(i);
      return row;
    }

    // boot
    initTheme();
    loadFacility();
    render();
    renderThemeToggle();

  </script>
</body>
</html>