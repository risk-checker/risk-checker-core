<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>risk-checker | night (WIP)</title>
  <style>
    /* -------------------------------------------------
       Theme system (auto / light / dark)
       - Fix: button text disappearing in dark mode
       - Keep UI readable on both PC and mobile
    ------------------------------------------------- */

    :root {
      --bg: #fafafa;
      --fg: #111;
      --muted: #666;

      --box-bg: #fff;
      --border: #e5e5e5;
      --card-border: #ddd;

      --note-bg: #f7f7f7;
      --note-border: #e5e5e5;

      --btn-bg: #fff;
      --btn-fg: #111;
      --btn-border: #ccc;
      --btn-bg-hover: #f0f0f0;

      --result-call-bg: #fdeaea;
      --result-call-border: #e0a1a1;
      --result-observe-bg: #eaf2ff;
      --result-observe-border: #a9c3f0;
      --result-sleep-bg: #eef7ef;
      --result-sleep-border: #a9d4ad;
    }

    html[data-theme="light"] { color-scheme: light; }
    html[data-theme="dark"]  { color-scheme: dark; }

    /* Auto follows OS preference */
    html[data-theme="auto"] { color-scheme: light dark; }

    html[data-theme="dark"] {
      --bg: #0b0c10;
      --fg: #f3f4f6;
      --muted: #a9adb7;

      --box-bg: #0f1117;
      --border: #2a2f3a;
      --card-border: #2a2f3a;

      --note-bg: #121624;
      --note-border: #2a2f3a;

      --btn-bg: #151a24;
      --btn-fg: #f3f4f6;
      --btn-border: #2a2f3a;
      --btn-bg-hover: #1a2030;

      --result-call-bg: #2a1212;
      --result-call-border: #7a2c2c;
      --result-observe-bg: #0f1a2f;
      --result-observe-border: #2b4a86;
      --result-sleep-bg: #0f2413;
      --result-sleep-border: #2f6a3a;
    }

    @media (prefers-color-scheme: dark) {
      html[data-theme="auto"] {
        --bg: #0b0c10;
        --fg: #f3f4f6;
        --muted: #a9adb7;

        --box-bg: #0f1117;
        --border: #2a2f3a;
        --card-border: #2a2f3a;

        --note-bg: #121624;
        --note-border: #2a2f3a;

        --btn-bg: #151a24;
        --btn-fg: #f3f4f6;
        --btn-border: #2a2f3a;
        --btn-bg-hover: #1a2030;

        --result-call-bg: #2a1212;
        --result-call-border: #7a2c2c;
        --result-observe-bg: #0f1a2f;
        --result-observe-border: #2b4a86;
        --result-sleep-bg: #0f2413;
        --result-sleep-border: #2f6a3a;
      }
    }

    @media (max-width: 600px){
      #theme-toggle { display:none; }
    }

    body {
      font-family: system-ui, -apple-system, "Hiragino Sans", "Noto Sans JP", sans-serif;
      margin: 24px;
      line-height: 1.6;
      background: var(--bg);
      color: var(--fg);
    }

    .box {
      max-width: 860px;
      background: var(--box-bg);
      padding: 20px;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    h1 { margin: 0 0 8px; font-size: 22px; }

    .note {
      background: var(--note-bg);
      border: 1px solid var(--note-border);
      padding: 12px 14px;
      border-radius: 10px;
      margin: 12px 0;
    }

    .row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; align-items:center; }

    button {
      padding: 9px 14px;
      border-radius: 8px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-fg);
      cursor: pointer;
      font-weight: 600;
    }

    button:hover { background: var(--btn-bg-hover); }

    button.primary { border-color: var(--btn-border); }
    button.danger { border-color: var(--result-call-border); }

    .card {
      border: 1px solid var(--card-border);
      border-radius: 10px;
      padding: 14px;
      margin: 12px 0;
      background: var(--box-bg);
    }

    .q-title { font-weight: 700; margin: 0 0 6px; }
    .muted { color: var(--muted); font-size: 13px; }

    .pill {
      display:inline-block;
      padding: 2px 10px;
      border:1px solid var(--btn-border);
      border-radius:999px;
      font-size: 12px;
      margin-left: 6px;
      color: var(--muted);
    }

    .result {
      padding: 14px;
      border-radius: 10px;
      border: 1px solid var(--card-border);
      background: var(--box-bg);
      margin-top: 12px;
      white-space: pre-wrap;
    }

    .result.call { background: var(--result-call-bg); border-color: var(--result-call-border); }
    .result.observe { background: var(--result-observe-bg); border-color: var(--result-observe-border); }
    .result.sleep { background: var(--result-sleep-bg); border-color: var(--result-sleep-border); }

    .hr { height:1px; background: var(--border); margin: 14px 0; }
    .small { font-size: 12px; color: var(--muted); }

    a { color: inherit; }
  </style>
</head>

<body>
  <div class="box">
    <h1>night checker (WIP)</h1>
    <div id="theme-toggle" class="row small" style="justify-content:flex-end"></div>

    <div class="note">
      <strong>注意：</strong>
      このツールは<strong>診断・評価・判断をしません</strong>。<br/>
      目的は「危険なサインを早めに拾う」ことと、「最終判断を必ず人間に返す」ことです。<br/>
      ここで行うのは<strong>Yes/No の事実確認</strong>のみです。
    </div>

    <div id="view"></div>

    <div class="hr"></div>

    <div class="small">
      ・このページは試作です。<br/>
      ・“OK”“安全”などの断定は出しません。<br/>
      ・必要なら GitHub 上の設計文書に戻る： <a href="https://github.com/risk-checker/risk-checker-core" target="_blank" rel="noreferrer">repo</a>
    </div>
  </div>

  <script>
    /**
     * --------------------------------------------------------------------
     *  State machine (最重要)
     *  - 判断を「人」から外すため、画面遷移を固定する
     * --------------------------------------------------------------------
     */

    const STATE = {
      START: "START",
      Q6: "Q6",
      RESULT_CALL: "RESULT_CALL",
      OBSERVE_30: "OBSERVE_30",
      OBSERVE_60: "OBSERVE_60",
      HANDOFF: "HANDOFF",
      SLEEP_CHECK: "SLEEP_CHECK",
    };

    // 6問（仮文言。あとで確定）
    const Q6 = [
      { id: "q1", text: "反応がない／意識がおかしい（普段ある反応がない）" },
      { id: "q2", text: "普段と比べて、息が苦しそう（話が続かない／息継ぎが増えた等）" },
      { id: "q3", text: "出血が止まっていない（清潔なガーゼ/ティッシュで押さえても、1分後にまだ出ている）" },
      { id: "q4", text: "本人が『耐えられない』と訴える強い痛みがある（普段より明らかに強い）" },
      { id: "q5", text: "普段歩ける人が、今は歩けない" },
      { id: "q6", text: "普段は不要な介助なのに、持ち上げた／抱えた動作があった" },
    ];

    // 睡眠チェック（起こす/起こさないだけ）
    const SLEEP = [
      { id: "s1", text: "呼吸の動きが確認できる（胸・腹部・布団の上下・鼻息など。触れずに確認）" },
      { id: "s2", text: "苦痛の発語（痛い・苦しい・助けて等）が30秒以上連続していない" },
      { id: "s3", text: "顔（鼻・口）が塞がっていない／胸や腹が何かに押しつぶされていない" },
    ];

    const model = {
      state: STATE.START,
      answers: Object.fromEntries(Q6.map(q => [q.id, null])),   // null / true / false
      sleep: Object.fromEntries(SLEEP.map(q => [q.id, null])), // null / true / false
      lastRunAt: null,   // 表示用（直近の6問実施時刻）
      firstRunAt: null,  // 初回6問を実施した時刻（30分/60分の基準）
      recheckRound: 0,   // 0=初回,1=30分後,2=60分後
      nextIfAllNo: STATE.OBSERVE_30, // 次に進む固定フロー（全てNoのとき）
      returnAfterSleep: STATE.Q6,    // 睡眠チェック後に戻す画面（導線固定）
    };

    const $view = () => document.getElementById("view");

    function nowText() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    function resetAll() {
      for (const k of Object.keys(model.answers)) model.answers[k] = null;
      for (const k of Object.keys(model.sleep)) model.sleep[k] = null;
      model.lastRunAt = null;
      model.firstRunAt = null;
      model.recheckRound = 0;
      model.nextIfAllNo = STATE.OBSERVE_30;
      model.returnAfterSleep = STATE.Q6;
      model.state = STATE.START;
      render();
    }

    function anyYes(obj) {
      return Object.values(obj).some(v => v === true);
    }

    function allYes(obj) {
      return Object.values(obj).every(v => v === true);
    }

    function setState(next) {
      model.state = next;
      render();
    }

    function render() {
      const v = $view();
      v.innerHTML = "";

      if (model.state === STATE.START) {
        v.appendChild(screenStart());
        return;
      }
      if (model.state === STATE.Q6) {
        v.appendChild(screenQ6());
        return;
      }
      if (model.state === STATE.RESULT_CALL) {
        v.appendChild(screenCall());
        return;
      }
      if (model.state === STATE.OBSERVE_30) {
        v.appendChild(screenObserve(30, STATE.OBSERVE_60));
        return;
      }
      if (model.state === STATE.OBSERVE_60) {
        v.appendChild(screenObserve(60, STATE.HANDOFF));
        return;
      }
      if (model.state === STATE.SLEEP_CHECK) {
        v.appendChild(screenSleep());
        return;
      }
      if (model.state === STATE.HANDOFF) {
        v.appendChild(screenHandoff());
        return;
      }
    }

    /**
     * Screens
     */

    function screenStart() {
      const wrap = div("card");
      wrap.appendChild(h2("起動（迷ったら起動）"));
      wrap.appendChild(p(
        "以下のいずれかが起きたら開始します：\n" +
        "・本人が体調不良/痛み/違和感を訴えた\n" +
        "・夜勤が『普段と違う可能性』を感じた\n" +
        "・転倒/衝突/出血など出来事があった\n" +
        "・第三者から異変の報告があった"
      ));

      const r = div("row");
      r.appendChild(btn("開始（6問へ）", () => {
        model.lastRunAt = nowText();
        model.firstRunAt = model.lastRunAt; // 初回6問の基準時刻
        model.recheckRound = 0;
        model.nextIfAllNo = STATE.OBSERVE_30;
        setState(STATE.Q6);
      }, "primary"));

      wrap.appendChild(r);
      wrap.appendChild(div("note", "※ このページは“判断”をしません。Yes/Noの事実確認のみです。"));
      return wrap;
    }

    function screenQ6() {
      const wrap = document.createElement("div");

      // safety: 初回の基準時刻が未設定なら、この時点を初回として固定する
      if (model.recheckRound === 0 && !model.firstRunAt) {
        model.firstRunAt = model.lastRunAt || nowText();
        if (!model.lastRunAt) model.lastRunAt = model.firstRunAt;
      }

      // Header
      const head = div("card");
      head.appendChild(h2(`6問（今この瞬間の事実のみ）${model.recheckRound===0?"（初回）":model.recheckRound===1?"（30分後の再実施）":"（60分後の再実施）"}`));
      head.appendChild(div("muted", `最終実行: ${model.lastRunAt ?? "未実行"}`));
      head.appendChild(div("note",
        "ルール：Q1〜Q6のどれか1つでも Yes → 『救急車（119）』。\n" +
        "全て No → 『経過観察（30分→60分）』。\n" +
        "※ 推測・原因・評価は禁止。\n" +
        "※ 本アプリの『普段』は“正常/理想”ではなく『本人のベースライン（いつも）』の比較軸を指す。"
      ));
      wrap.appendChild(head);

      // Recheck pre-check (30/60分後の再実施では、まず睡眠/起床状態を確認する導線を上に出す)
      if (model.recheckRound > 0) {
        const pre = div("card");
        pre.appendChild(h2("再確認の前に：起こして確認できる状態か？"));
        pre.appendChild(div(
          "note",
          "30分後/60分後の再確認では、まず『起こして6問を実施できる状態か』を確認します。\n" +
          "睡眠か不明な場合は、先に睡眠チェックへ進みます（救急車の判定はしない）。"
        ));
        const rr = div("row");
        rr.appendChild(btn("睡眠か不明 → 睡眠チェックへ", () => {
          model.returnAfterSleep = STATE.Q6;
          setState(STATE.SLEEP_CHECK);
        }, "primary"));
        rr.appendChild(btn("起きている/確認できる → このまま6問を続ける", () => {
          // 何もしない（画面をそのまま）
        }));
        pre.appendChild(rr);
        wrap.appendChild(pre);
      }
      // Questions
      Q6.forEach((q, i) => {
        const card = div("card");
        const title = document.createElement("div");
        title.className = "q-title";
        title.textContent = `Q${i+1}. ${q.text}`;
        card.appendChild(title);

        const r = div("row");
        r.appendChild(btn("Yes", () => { model.answers[q.id] = true; render(); }, "danger"));
        r.appendChild(btn("No", () => { model.answers[q.id] = false; render(); }));
        r.appendChild(spanPill(model.answers[q.id]));
        card.appendChild(r);

        wrap.appendChild(card);
      });

      // Actions
      const foot = div("card");
      foot.appendChild(h2("判定（自動）"));

      const undecided = Object.values(model.answers).some(v => v === null);
      const info = div("muted", undecided
        ? "※ 未回答があります。すべて回答してから確定してください。"
        : "※ すべて回答済みです。"
      );
      foot.appendChild(info);

      const r = div("row");
      r.appendChild(btn("確定する", () => {
        if (Object.values(model.answers).some(v => v === null)) return;
        if (anyYes(model.answers)) {
          setState(STATE.RESULT_CALL);
        } else {
          setState(model.nextIfAllNo);
        }
      }, "primary"));


      r.appendChild(btn("最初からやり直す", () => resetAll()));
      foot.appendChild(r);

      wrap.appendChild(foot);
      return wrap;
    }

    function screenCall() {
      const wrap = document.createElement("div");
      const card = div("card");
      card.appendChild(h2("表示：救急車（119）"));
      card.appendChild(div("result call",
        "✅ 条件一致：6問のうち1つ以上が Yes。\n" +
        "行動：119へ通報。\n" +
        "注意：搬送先の判断は救急隊へ。ここは判断しない。"
      ));
      card.appendChild(div("note",
        "伝える内容（例）\n" +
        "・施設名 / 住所\n" +
        "・年齢・性別（分かる範囲）\n" +
        "・Yesになった事実（Q番号）\n" +
        "※ 推測・原因・結論は言わない"
      ));

      const r = div("row");
      r.appendChild(btn("6問へ戻る（状況変化）", () => setState(STATE.Q6)));
      r.appendChild(btn("最初からやり直す", () => resetAll()));
      card.appendChild(r);

      wrap.appendChild(card);
      return wrap;
    }

    function screenObserve(mins, nextState) {
      const card = div("card");
      card.appendChild(h2(`表示：経過観察（初回6問から${mins}分で再実施）`));
      card.appendChild(div("result observe",
        "✅ 条件一致：6問がすべて No。\n" +
        "行動：固定の経過観察へ。\n" +
        "※ 30分/60分は『初回に6問を実施した時刻』からの経過時間。\n" +
        `　初回6問：${model.firstRunAt ?? "未記録"}` + "\n" +
        "※ タイマーは実装しない（現場の時計でOK）。"
      ));

      const r = div("row");
      r.appendChild(btn(`初回から${mins}分経過したら：6問を再実施する`, () => {
        // 再実施は必ず6問へ戻す（UIを自然に誘導する）
        model.lastRunAt = nowText();
        for (const k of Object.keys(model.answers)) model.answers[k] = null;

        if (mins === 30) {
          model.recheckRound = 1;
          model.nextIfAllNo = STATE.OBSERVE_60;
        } else {
          model.recheckRound = 2;
          model.nextIfAllNo = STATE.HANDOFF;
        }

        setState(STATE.Q6);
      }, "primary"));

      r.appendChild(btn("いま悪化/新規事象（最初から6問）", () => {
        model.lastRunAt = nowText();
        // 回答は残しても良いが、原則は再起動なので一旦回答クリア
        for (const k of Object.keys(model.answers)) model.answers[k] = null;
        setState(STATE.Q6);
      }, "danger"));

      r.appendChild(btn("寝ている可能性がある（未確定）→睡眠チェックへ", () => {
        model.returnAfterSleep = nextState;
        setState(STATE.SLEEP_CHECK);
      }));

      r.appendChild(btn("最初からやり直す", () => resetAll()));
      card.appendChild(r);

      card.appendChild(div("note",
        "補足：経過観察中の連絡・相談は“してもよい”。ただしこの画面の判定を上書きしない。\n" +
        "（判断を誰かに渡して揺らすのを防ぐため）"
      ));

      return card;
    }

    function screenSleep() {
      const wrap = document.createElement("div");
      const card = div("card");
      card.appendChild(h2("睡眠チェック（睡眠か不明のときの補助）"));
      card.appendChild(div("note",
        "ここで決めるのは『起こして6問を実施する』か『起こさず観察を続ける』のみ。\n" +
        "救急車の判定はしない。\n" +
        "不明が1つでもあれば『起こして6問へ戻す』に倒す。\n" +
        "（表示とボタンが矛盾しないよう、結果に応じて出るボタンを自動で絞ります）"
      ));
      wrap.appendChild(card);

      SLEEP.forEach((q, i) => {
        const c = div("card");
        const title = document.createElement("div");
        title.className = "q-title";
        title.textContent = `S${i+1}. ${q.text}`;
        c.appendChild(title);

        const r = div("row");
        r.appendChild(btn("Yes", () => { model.sleep[q.id] = true; render(); }, "primary"));
        r.appendChild(btn("No", () => { model.sleep[q.id] = false; render(); }, "danger"));
        r.appendChild(btn("不明", () => { model.sleep[q.id] = null; render(); }));
        r.appendChild(spanPill(model.sleep[q.id]));
        c.appendChild(r);

        wrap.appendChild(c);
      });

      const decision = div("card");
      decision.appendChild(h2("結果（自動）"));

      const hasNull = Object.values(model.sleep).some(v => v === null);
      if (hasNull) {
        decision.appendChild(div("result sleep",
          "⚠ 未回答/不明があります。\n" +
          "不明が残る場合は『起こして6問へ戻す』に倒してください。"
        ));
      } else if (allYes(model.sleep)) {
        decision.appendChild(div("result sleep",
          "✅ すべて Yes。\n" +
          "行動：起こさない（睡眠継続）。\n" +
          "※ 状況変化があれば最初から6問へ。"
        ));
      } else {
        decision.appendChild(div("result sleep",
          "⚠ 1つ以上 No。\n" +
          "行動：起こして6問へ戻す（意識/呼吸等の事実確認へ）。"
        ));
      }

      const r = div("row");

      const hasNull2 = Object.values(model.sleep).some(v => v === null);
      const allYes2 = !hasNull2 && allYes(model.sleep);

      // ルール：表示（自動）とボタンが矛盾しないようにする
      // - 「すべてYes」＝起こさない（観察継続）を主ボタンにし、「起こして戻す」は出さない
      // - 不明/Noがある＝起こして6問へ戻すを主ボタンにする

      if (allYes2) {
        r.appendChild(btn("起こさない（観察を続ける）", () => {
          // 観察継続：次の段階へ（30→60→日勤）
          setState(model.returnAfterSleep);
        }, "primary"));

        r.appendChild(btn("状況変化があれば：最初から6問へ", () => {
          for (const k of Object.keys(model.answers)) model.answers[k] = null;
          model.lastRunAt = nowText();
          setState(STATE.Q6);
        }));

      } else {
        r.appendChild(btn("起こして6問へ戻す", () => {
          // 睡眠チェックは補助なので、6問側を再起動
          for (const k of Object.keys(model.answers)) model.answers[k] = null;
          model.lastRunAt = nowText();
          setState(STATE.Q6);
        }, "primary"));

        r.appendChild(btn("戻る（前の画面へ）", () => {
          setState(STATE.Q6);
        }));
      }

      r.appendChild(btn("最初からやり直す", () => resetAll()));

      decision.appendChild(r);
      wrap.appendChild(decision);

      return wrap;
    }

    function screenHandoff() {
      const card = div("card");
      card.appendChild(h2("引き継ぎ（夜間の判断をここで止める）"));
      card.appendChild(div("result observe",
        "ここから先（翌日通院、家族調整、服薬/生活対応の主体決定）は日勤帯。\n" +
        "夜勤は『事実』と『実施した対応』だけを残す。"
      ));
      card.appendChild(div("note",
        "残すもの（例）\n" +
        "・起動時刻 / きっかけ（訴え・転倒等）\n" +
        "・6問の回答（Yes/No）\n" +
        "・経過観察の実施（30分/60分）\n" +
        "・睡眠チェックの有無\n" +
        "※ 評価・推測・誰が悪いは禁止"
      ));

      const r = div("row");
      r.appendChild(btn("6問へ戻る（状況変化）", () => {
        model.lastRunAt = nowText();
        for (const k of Object.keys(model.answers)) model.answers[k] = null;
        setState(STATE.Q6);
      }));
      r.appendChild(btn("最初からやり直す", () => resetAll()));
      card.appendChild(r);
      return card;
    }

    /**
     * UI helpers
     */

    function h2(text) {
      const el = document.createElement("div");
      el.className = "q-title";
      el.textContent = text;
      return el;
    }

    function p(text) {
      const el = document.createElement("div");
      el.style.whiteSpace = "pre-wrap";
      el.textContent = text;
      return el;
    }

    function div(className, text) {
      const el = document.createElement("div");
      if (className) el.className = className;
      if (text !== undefined) {
        el.style.whiteSpace = "pre-wrap";
        el.textContent = text;
      }
      return el;
    }

    function btn(label, onClick, extraClass) {
      const b = document.createElement("button");
      if (extraClass) b.className = extraClass;
      b.textContent = label;
      b.onclick = onClick;
      return b;
    }

    function spanPill(value) {
      const s = document.createElement("span");
      s.className = "pill";
      if (value === true) s.textContent = "Yes";
      else if (value === false) s.textContent = "No";
      else s.textContent = "未回答";
      return s;
    }

    // boot
    render();

    // -------------------------------------------------
    // Theme toggle (PC only): auto / light / dark
    // -------------------------------------------------
    const THEME_KEY = "night-theme"; // auto | light | dark

    function applyTheme(mode){
      document.documentElement.dataset.theme = mode;
      localStorage.setItem(THEME_KEY, mode);
    }

    function renderThemeToggle(){
      const wrap = document.getElementById("theme-toggle");
      if(!wrap) return;

      // Clear
      wrap.innerHTML = "";

      const label = document.createElement("span");
      label.textContent = "表示モード：";
      label.style.marginRight = "6px";
      wrap.appendChild(label);

      const options = [
        { mode: "auto",  text: "自動" },
        { mode: "light", text: "ライト" },
        { mode: "dark",  text: "ダーク" },
      ];

      options.forEach(({mode, text})=>{
        const b = document.createElement("button");
        b.type = "button";
        b.textContent = text;
        b.setAttribute("aria-label", `表示モード: ${text}`);
        b.onclick = ()=>applyTheme(mode);
        wrap.appendChild(b);
      });
    }

    function initTheme(){
      const saved = localStorage.getItem(THEME_KEY) || "auto";
      document.documentElement.dataset.theme = saved;
    }

    initTheme();
    renderThemeToggle();
  </script>
</body>
</html>